<!doctype html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Gyro </title>

</head>


<style>
 /body 
  {
  	overflow:hidden; 
	margin: 0px;
	padding: 0px;
	font-size:60px;
	position: fixed;
}
  canvas
  { 
	margin: 0px;
	padding: 0px;
	position:fixed;
	left:0px;
    top:0px;
	
  } 
 img
  { 
	margin: 0px;
	padding: 0px;
	position:fixed;
	
	
  } 
  
</style>
 

<body >
	alpha:<span id="alpha"></span><br>
	beta:<span id="beta"></span><br>
	gamma:<span id="gamma"></span><br>
	L1:<span id="X"></span><br>
	Y:<span id="Y" style ="z-index: 4;"></span><br>
	Z:<span id="Z" style ="z-index: 4;"></span><br>
	
	<canvas id="myCanvas" style=" border:6px solid;z-index: 4; "></canvas> 
	<canvas id="myCanvas2" style="  solid;z-index: 3; "></canvas> 
	<img id="img1" src="frame.jpg" style ="z-index: 2;">
	<img id="img2" src="space.jpg" style =" width:1920; height:1080; top:-1px ; left:-1px ;z-index: 1;">
	
</body>
<script type="text/javascript">

 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//===============================================================================================================================================================================
    document.addEventListener("touchStart", touchStartFunc, true);//?misspelled
	document.addEventListener("touchmove", touchmoveFunc, true);
	document.addEventListener("touchend", touchEndFunc, true);

    var canvas = document.getElementById('myCanvas');
    var context = canvas.getContext('2d');
    var canvas2 = document.getElementById('myCanvas2');
    var context2 = canvas2.getContext('2d');

    
    var width=window.innerWidth;
    var height=window.innerHeight;
    context.canvas.width  = width;//resize canvas to whatever window dimensions are
	context.canvas.height = height;
   	context.translate(canvas.width / 2, canvas.height / 2); 
     //put 0,0,0 origin at center of screen instead of upper left corner
    var first=0; 
    var deviceOrientationData ={alpha:0,beta:0,gamma:0};//init with 0 as defaults  
    var x=0;
    var y=0;
    var z=0;
    var startY;
    var startZ;
     var radius = 70;
    
    var L1=600;
    var bitTouch=false;
    var userX=0;
	var userY=0;
	var firstX=0;
	var firstY=0;
    document.getElementById("img2").width  =width*1.5;
    document.getElementById("img2").height  =height*1.5;
    document.getElementById("img2").style.top  =-300;
    document.getElementById("img2").style.left  =-300;
    document.getElementById("img1").width  =width-300;
    document.getElementById("img1").height  =height-300;
    var imgWidth=document.getElementById("img1").width;
    var imgHeight=document.getElementById("img1").height;
    console.log(imgWidth);
    console.log(imgHeight);
    
	context2.canvas.width  = imgWidth;//resize canvas to whatever window dimensions are
	context2.canvas.height = imgHeight;
	context2.translate(canvas2.width / 2, canvas2.height / 2);
    if (window.DeviceOrientationEvent) 
    {//
    	
    	window.addEventListener("deviceorientation", function () {//gyro
    	if (first==0)
    	{
    		startZ=Math.cos(degToRad(event.beta))*L1;
    		startY=Math.sin(degToRad(event.beta))*L1;
    		first=1;	
    	}	
    	
        processGyro(event.alpha, event.beta, event.gamma); 
    	}, true);
    	
	}

	

	function drawCir(xx,yy)
	{
		context.beginPath();
	    context.arc(xx, yy, radius, 0, 2 * Math.PI, false);

	    // context.fillStyle = 'green';
	    //context.fill();
	    context.lineWidth = 5;
	    context.strokeStyle = '#003300';
	    context.stroke();  

	    context.beginPath();
	    context.lineWidth = 1;
	    context.moveTo(xx-radius,yy);
		context.lineTo(xx+radius, yy);
		context.moveTo(xx,radius+yy);
		context.lineTo(xx,-radius+yy);
	    context.strokeStyle = '#003300';
	    context.stroke();  
	}
	function drawCir2(xx,yy)
	{
		context2.beginPath();
	    context2.arc(xx, yy, radius-60, 0, 2 * Math.PI, false);

	    // context.fillStyle = 'green';
	    //context.fill();
	    context2.lineWidth = 2;
	    context2.strokeStyle = '#003300';
	    context2.stroke();  

	    
	}


function processGyro(alpha,beta,gamma)
{ 
	deviceOrientationData.alpha=alpha;
	deviceOrientationData.beta=beta;
	deviceOrientationData.gamma=gamma;
	rotatePointViaGyroEulars(0,startY,startZ);
	
	if (bitTouch)
	{
		drawCir2(userX+x,userY-y);	
	}
		context.save();
		context.setTransform(1, 0, 0, 1, 0, 0);
		context.clearRect(0, 0, canvas.width, canvas.height);
		context.restore();
		drawCir(0+userX,0+userY);
	

	document.getElementById("img1").style.left  =-x+ width/2-imgWidth/2+"px";
	document.getElementById("img1").style.top  = y+height/2-imgHeight/2+"px";
	document.getElementById("myCanvas2").style.left  =-x+ width/2-imgWidth/2+"px";
	document.getElementById("myCanvas2").style.top  = y+height/2-imgHeight/2+"px";
	//note: this code is much simpler but less obvious: function processGyro(event){deviceOrientationData = event;}
	
	document.getElementById("alpha").innerHTML=alpha;
	document.getElementById("beta").innerHTML=startY;
	document.getElementById("gamma").innerHTML =startZ;
	document.getElementById("X").innerHTML =bitTouch;
	document.getElementById("Y").innerHTML =firstX;
	document.getElementById("Z").innerHTML =userX;

}



function degToRad(deg)// Degree-to-Radian conversion
{
	 return deg * Math.PI / 180; 
}


function rotatePointViaGyroEulars(a,b,c) //rotates 3d point based on eular angles
{
	var oldX=0;
	var oldY=-startY;
	var oldZ=startZ;
	
	//order here is important - it must match the processing order of the device
	
	//rotate about z axis
	var newX = oldX * Math.cos(-degToRad(deviceOrientationData.alpha)) - oldY * Math.sin(-degToRad(deviceOrientationData.alpha));
	var newY = oldY * Math.cos(-degToRad(deviceOrientationData.alpha)) + oldX * Math.sin(-degToRad(deviceOrientationData.alpha));
	
	//rotate about x axis
	oldY=newY;
	newY = oldY * Math.cos(-degToRad(deviceOrientationData.beta)) - oldZ * Math.sin(-degToRad(deviceOrientationData.beta));
	var newZ = oldZ * Math.cos(-degToRad(deviceOrientationData.beta)) + oldY * Math.sin(-degToRad(deviceOrientationData.beta));

	
	//rotate about y axis
	oldZ=newZ;
	oldX=newX;

	newZ = oldZ * Math.cos(-degToRad(deviceOrientationData.gamma)) - oldX * Math.sin(-degToRad(deviceOrientationData.gamma));
	newX = oldX * Math.cos(-degToRad(deviceOrientationData.gamma)) + oldZ * Math.sin(-degToRad(deviceOrientationData.gamma));
	document.getElementById("alpha").innerHTML=oldZ;
	x=newX;
	y=newY;
	z=newZ;

	
}
function computeQuaternionFromEulers(alpha,beta,gamma)//Alpha around Z axis, beta around X axis and gamma around Y axis intrinsic local space in that order(each axis moves depending on how the other moves so processing order is important)
{
	var qx = degToRad(beta) ; // beta value
	var qy = degToRad(gamma) ; // gamma value
	var qz = degToRad(alpha) ; // alpha value

	//precompute to save on processing time
	var cX = Math.cos( x/2 );
	var cY = Math.cos( y/2 );
	var cZ = Math.cos( z/2 );
	var sX = Math.sin( x/2 );
	var sY = Math.sin( y/2 );
	var sZ = Math.sin( z/2 );

	var qw = cX * cY * cZ - sX * sY * sZ;
	var qx = sX * cY * cZ - cX * sY * sZ;
	var qy = cX * sY * cZ + sX * cY * sZ;
	var qz = cX * cY * sZ + sX * sY * cZ;

	x=qx;
	y=qy;
	z=qz;	  
}
window.addEventListener('orientationchange', function () {
    if (window.orientation == -90) {
        document.getElementById('orient').className = 'orientright';
    }
    if (window.orientation == 90) {
        document.getElementById('orient').className = 'orientleft';
    }
    if (window.orientation == 0) {
        document.getElementById('orient').className = '';
    }
}, true);
//========================================================================================================================================================================
//========================================================================================================================================================================


function touchStartFunc(e)
{
	
	if (!(bitTouch))
	{
		
		firstX=e.touches[0].clientX;
		firstY=e.touches[0].clientY;
		bitTouch=true;
	}
}

function touchmoveFunc(e)
{
	
	if( navigator.userAgent.match(/Android/i) ) //stupid android bug cancels touch move if it thinks there's a swipe happening
	{   
	  e.preventDefault();
	}
	userXYmove(e.touches[0].clientX,e.touches[0].clientY);
	if (!(bitTouch))
	{
		
		firstX=e.touches[0].clientX;
		firstY=e.touches[0].clientY;
	}
	bitTouch=true;
	 prevTouchX =e.touches[0].clientX;
	 prevTouchY =e.touches[0].clientY;
}

function touchEndFunc(e)
{
	
  prevTouchX = -1;
  prevTouchY = -1;
  userX=0;
	userY=0;
	bitTouch=false;
}
function userXYmove(ux,uy)
{

	
	
	if(prevTouchX != -1 ) //need valid prevTouch info to calculate swipe
	{
	  var xMovement=ux-prevTouchX;
	  var yMovement=uy-prevTouchY;
	  userX=ux-firstX;
	  userY=uy-firstY;
	  //var xMovementQuat=quatFromAxisAngle(1,0,0,y/200);//movement on y rotates x and vice versa
	  //var yMovementQuat=quatFromAxisAngle(0,1,0,x/200);//200 is there to scale the movement way down to an intuitive amount
	 //userQuot=quaternionMultiply([yMovementQuat,xMovementQuat]);//use reverse order
	 
	}
	prevTouchY=uy;
	prevTouchX=ux;
}

		
 </script>
</html>