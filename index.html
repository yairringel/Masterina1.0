<!doctype html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Gyro </title>

</head>


<style>
  body 
  {
	margin: 0px;
	padding: 0px;
	font-size:60px;
	position: fixed;
}
  canvas
  { 
	margin: 0px;
	padding: 0px;
	position: absolute;
	left:0px;
    top:0px;
	
  } 
  img
  { 
	margin: 0px;
	padding: 0px;
	position: absolute;
	left:-120px;
    top:-210px;
	
  } 
  
</style>
 

<body >
	alpha:<span id="alpha"></span><br>
	beta:<span id="beta"></span><br>
	gamma:<span id="gamma"></span><br>
	L1:<span id="X"></span><br>
	Y:<span id="Y"></span><br>
	Z:<span id="Z"></span><br>
	
	<canvas id="myCanvas" style="border:6px solid;z-index: 3; "></canvas> 
	<img src="bg.jpg" style="border:2px solid;z-index: -2;">
	
</body>
<script type="text/javascript">

    
    var canvas = document.getElementById('myCanvas');
    var context = canvas.getContext('2d');
    var initialBeta = 1000;
    
    context.canvas.width  = window.innerWidth;//resize canvas to whatever window dimensions are
	context.canvas.height = window.innerHeight;
    var radius = 70;
    context.translate(canvas.width / 2, canvas.height / 2); //put 0,0,0 origin at center of screen instead of upper left corner
    var first=0; 
    var deviceOrientationData ={alpha:0,beta:0,gamma:0};//init with 0 as defaults  
    var x=0;
    var y=0;
    var z=0;
    var startY;
    var startZ;
    var pointRA=[];
    var L1=500;
    if (window.DeviceOrientationEvent) 
    {//
    	
    	window.addEventListener("deviceorientation", function () {//gyro
    	if (first==0)
    	{
    		startZ=Math.cos(degToRad(event.beta))*L1;
    		startY=Math.sin(degToRad(event.beta))*L1;
    		first=1;	
    	}	
    	
        processGyro(event.alpha, event.beta, event.gamma); 
    	}, true);
    	
	}

	

	function drawCir(xx,yy)
	{
		context.beginPath();
	    context.arc(xx, yy, radius, 0, 2 * Math.PI, false);
	    context.fillStyle = 'green';
	    context.fill();
	    context.lineWidth = 5;
	    context.strokeStyle = '#003300';
	    context.stroke();  
	}



	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//===============================================================================================================================================================================




function processGyro(alpha,beta,gamma)
{ 
	deviceOrientationData.alpha=alpha;
	deviceOrientationData.beta=beta;
	deviceOrientationData.gamma=gamma;
	rotatePointViaGyroEulars(0,startY,startZ);
	drawCir(-x,y);
	//note: this code is much simpler but less obvious: function processGyro(event){deviceOrientationData = event;}
	
	document.getElementById("alpha").innerHTML=alpha;
	document.getElementById("beta").innerHTML=startY;
	document.getElementById("gamma").innerHTML =startZ;
	document.getElementById("X").innerHTML =x;
	document.getElementById("Y").innerHTML =y;
	document.getElementById("Z").innerHTML =z;
	
}



function degToRad(deg)// Degree-to-Radian conversion
{
	 return deg * Math.PI / 180; 
}


function rotatePointViaGyroEulars(a,b,c) //rotates 3d point based on eular angles
{
	var oldX=0;
	var oldY=-startY;
	var oldZ=startZ;
	
	//order here is important - it must match the processing order of the device
	
	//rotate about z axis
	var newX = oldX * Math.cos(-degToRad(deviceOrientationData.alpha)) - oldY * Math.sin(-degToRad(deviceOrientationData.alpha));
	var newY = oldY * Math.cos(-degToRad(deviceOrientationData.alpha)) + oldX * Math.sin(-degToRad(deviceOrientationData.alpha));
	
	//rotate about x axis
	oldY=newY;
	newY = oldY * Math.cos(-degToRad(deviceOrientationData.beta)) - oldZ * Math.sin(-degToRad(deviceOrientationData.beta));
	var newZ = oldZ * Math.cos(-degToRad(deviceOrientationData.beta)) + oldY * Math.sin(-degToRad(deviceOrientationData.beta));

	
	//rotate about y axis
	oldZ=newZ;
	oldX=newX;

	newZ = oldZ * Math.cos(-degToRad(deviceOrientationData.gamma)) - oldX * Math.sin(-degToRad(deviceOrientationData.gamma));
	newX = oldX * Math.cos(-degToRad(deviceOrientationData.gamma)) + oldZ * Math.sin(-degToRad(deviceOrientationData.gamma));
	document.getElementById("alpha").innerHTML=oldZ;
	x=newX;
	y=newY;
	z=newZ;

	
}
function computeQuaternionFromEulers(alpha,beta,gamma)//Alpha around Z axis, beta around X axis and gamma around Y axis intrinsic local space in that order(each axis moves depending on how the other moves so processing order is important)
{
	var qx = degToRad(beta) ; // beta value
	var qy = degToRad(gamma) ; // gamma value
	var qz = degToRad(alpha) ; // alpha value

	//precompute to save on processing time
	var cX = Math.cos( x/2 );
	var cY = Math.cos( y/2 );
	var cZ = Math.cos( z/2 );
	var sX = Math.sin( x/2 );
	var sY = Math.sin( y/2 );
	var sZ = Math.sin( z/2 );

	var qw = cX * cY * cZ - sX * sY * sZ;
	var qx = sX * cY * cZ - cX * sY * sZ;
	var qy = cX * sY * cZ + sX * cY * sZ;
	var qz = cX * cY * sZ + sX * sY * cZ;

	x=qx;
	y=qy;
	z=qz;	  
}
window.addEventListener('orientationchange', function () {
    if (window.orientation == -90) {
        document.getElementById('orient').className = 'orientright';
    }
    if (window.orientation == 90) {
        document.getElementById('orient').className = 'orientleft';
    }
    if (window.orientation == 0) {
        document.getElementById('orient').className = '';
    }
}, true);
//========================================================================================================================================================================
//========================================================================================================================================================================

		
 </script>
</html>