<!doctype html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Gyro </title>

</head>


<style>
  body 
  {
	margin: 0px;
	padding: 0px;
	font-size:60px;
	position: fixed;
}
  canvas
  { 
	margin: 0px;
	padding: 0px;
	position: absolute;
	left:0px;
    top:0px;
	
  } 
</style>
 

<body >
	alpha:<span id="alpha"></span><br>
	beta:<span id="beta"></span><br>
	gamma:<span id="gamma"></span><br>
	Beta:<span id="Beta"></span><br>
	Gamma:<span id="Gamma"></span><br>
	
	<canvas id="myCanvas" style="border:2px solid;z-index: 3; "></canvas> 
	<img src="masterina.png" style="position:absolute;left:2px;z-index: 2;">
	<img src="masterina2.png" style="position:absolute;left:2px;z-index: 1;">
</body>
<script type="text/javascript">


    var canvas = document.getElementById('myCanvas');
    var context = canvas.getContext('2d');
    var initialBeta = 1000;
    var Beta=0;
    var Gamma=0;
    context.canvas.width  = window.innerWidth;//resize canvas to whatever window dimensions are
	context.canvas.height = window.innerHeight;
    var centerX = canvas.width / 2;
    var centerY = canvas.height / 2;
    var radius = 70;

    context.beginPath();
    context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
    context.fillStyle = 'green';
    context.fill();
    context.lineWidth = 5;
    context.strokeStyle = '#003300';
    context.stroke();  
      
    


    if (window.DeviceOrientationEvent) 
    {//
    	
    	window.addEventListener("deviceorientation", function () {//gyro
    		if (initialBeta == 1000)
    	{
    		initialBeta=event.beta;
    		initialGamma=event.gamma;
    	}
    	Beta=event.beta-initialBeta;
    	Gamma=event.gamma-initialGamma;
        processGyro(event.alpha, event.beta, event.gamma); 
    	}, true);
    	
	}

	

	function drawCir(beta,gamma)
	{
		context.beginPath();
	    context.arc(Gamma*3, Beta*3, radius, 0, 2 * Math.PI, false);
	    context.fillStyle = 'green';
	    context.fill();
	    context.lineWidth = 5;
	    context.strokeStyle = '#003300';
	    context.stroke();  
	}



	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//===============================================================================================================================================================================
	var deviceOrientationData ={alpha:0,beta:0,gamma:0};//init with 0 as defaults



function processGyro(alpha,beta,gamma)
{ 
	deviceOrientationData.alpha=alpha;
	deviceOrientationData.beta=beta;
	deviceOrientationData.gamma=gamma;
	//note: this code is much simpler but less obvious: function processGyro(event){deviceOrientationData = event;}
	
	document.getElementById("alpha").innerHTML=alpha;
	document.getElementById("beta").innerHTML=beta;
	document.getElementById("gamma").innerHTML =gamma;
	document.getElementById("Beta").innerHTML =Beta;
	document.getElementById("Gamma").innerHTML =Gamma;
	drawCir(Beta,Gamma);
}

context.translate(canvas.width / 2, canvas.height / 2); //put 0,0,0 origin at center of screen instead of upper left corner

function degToRad(deg)// Degree-to-Radian conversion
{
	 return deg * Math.PI / 180; 
}

function makeRect(width,height,depth)//returns a 3D box like object centered around the origin. There are more than 8 points for this cube as it is being made by chaining together a strip of triangles so points are redundant at least 3x. Confusing for now (sorry) but this odd structure comes in handy later for transitioning into webgl
{
	var newObj={};
	var hw=width/2;
	var hh=height/2;
	var hd=depth/2;
	newObj.vertices=[  [-hw,hh,hd],[hw,hh,hd],[hw,-hh,hd],//first triangle
					 
	];
	
	return newObj;
}

var cube=makeRect(canvas.width/5,canvas.width/5,canvas.width/5);
cube.color="purple";

//render loop
function renderLoop() 
{
  requestAnimationFrame( renderLoop );//better than set interval as it pauses when browser isn't active
  context.clearRect( -canvas.width/2, -canvas.height/2, canvas.width, canvas.height);//clear screen x, y, width, height
  
  //create some fake data in case web page isn't being accessed from a mobile or gyro enabled device
  if(!( window.DeviceOrientationEvent && 'ontouchstart' in window))
  {
	this.fakeAlpha = (this.fakeAlpha || 0)+ .0;//z axis - use 0 to turn off rotation
	this.fakeBeta = (this.fakeBeta || 0)+ .7;//x axis
	this.fakeGamma = (this.fakeGamma || 0)+ .5;//y axis
	processGyro(this.fakeAlpha,this.fakeBeta,this.fakeGamma);
  }
  
  renderObj(cube);
  
}
renderLoop();

function renderObj(obj)//renders an object as a series of triangles
{
	var rotatedObj=rotateObject(obj);
	context.lineWidth = 1;
	context.strokeStyle = obj.color;
	
	for(var i=0 ; i<obj.vertices.length ; i+=3)
	{
		for (var k=0;k<3;k++)
		{
		  var vertexFrom=rotatedObj.vertices[i+k];
		  var temp=i+k+1;
		  if(k==2) 
			  temp=i;
			  
		  var vertexTo=rotatedObj.vertices[temp];		
		  context.beginPath();
		  context.moveTo(scaleByZ(vertexFrom[0],vertexFrom[2]), -scaleByZ(vertexFrom[1],vertexFrom[2]));
		  context.lineTo(scaleByZ(vertexTo[0],vertexTo[2]), -scaleByZ(vertexTo[1],vertexTo[2]));
		  context.stroke();
		}
	}
}

function scaleByZ(val,z)
{
	var focalLength=900; //pick any value that looks good
	var scale= focalLength/((-z)+focalLength);
	return val*scale;
}

function rotateObject(obj) //rotates obeject
{
	var newObj={};
	newObj.vertices=[];
	for(var i=0 ; i<obj.vertices.length ; i++)
	{
	  newObj.vertices.push(rotatePointViaGyroEulars(obj.vertices[i]));
	}
	return newObj;
}

function rotatePointViaGyroEulars(ra) //rotates 3d point based on eular angles
{
	var oldX=ra[0];
	var oldY=ra[1];
	var oldZ=ra[2];
	
	//order here is important - it must match the processing order of the device
	
	//rotate about z axis
	var newX = oldX * Math.cos(-degToRad(deviceOrientationData.alpha)) - oldY * Math.sin(-degToRad(deviceOrientationData.alpha));
	var newY = oldY * Math.cos(-degToRad(deviceOrientationData.alpha)) + oldX * Math.sin(-degToRad(deviceOrientationData.alpha));
	
	//rotate about x axis
	oldY=newY;
	newY = oldY * Math.cos(-degToRad(deviceOrientationData.beta)) - oldZ * Math.sin(-degToRad(deviceOrientationData.beta));
	var newZ = oldZ * Math.cos(-degToRad(deviceOrientationData.beta)) + oldY * Math.sin(-degToRad(deviceOrientationData.beta));

	
	//rotate about y axis
	oldZ=newZ;
	oldX=newX;

	newZ = oldZ * Math.cos(-degToRad(deviceOrientationData.gamma)) - oldX * Math.sin(-degToRad(deviceOrientationData.gamma));
	newX = oldX * Math.cos(-degToRad(deviceOrientationData.gamma)) + oldZ * Math.sin(-degToRad(deviceOrientationData.gamma));

	
	return [newX,newY,newZ];
}

//========================================================================================================================================================================
//========================================================================================================================================================================

		
 </script>
</html>